#!/usr/bin/env python3


def brace_str(n, k):
    t = [ f'%{i}' for i in range(k,k+n) ]
    t = ', '.join(t)
    return '{' + t + '}'


def elt_str(s, i, ptxtype=None, const=False):
    var = f'{s}[{i}]'
    if ptxtype is not None:
        cv = 'const ' if const else ''
        var = f'*({cv}{ptxtype} *) &{var}'
        
    constraint = '"r"' if const else '"=r"'
    return f'{constraint} ({var})'

    
def arr_str(s, n, ptxtype=None, const=False):
    elts = [ elt_str(s,i,ptxtype,const) for i in range(n) ]
    return ', '.join(elts)


def generate_mma(stype, m, n, k):
    sf, ptxtype = '', None

    if stype == 's4':
        sbits, dbits, dtype, cudatype, sf = 4, 32, 's32', 'int', '.satfinite'
    elif stype == 's8':
        sbits, dbits, dtype, cudatype, sf = 8, 32, 's32', 'int', '.satfinite'
    elif stype == 'f16':
        sbits, dbits, dtype, cudatype, ptxtype = 16, 16, 'f16', '__half2', 'unsigned int'
    else:
        raise RuntimeError(f"Unrecognized stype '{stype}'")
        
    na = (m*k*sbits) // 1024
    nb = (k*n*sbits) // 1024
    nc = (m*n*dbits) // 1024

    print(f'')
    print(f'// D = A*B + C')
    print(f'__device__ __forceinline__')
    print(f'void mma_{stype}_m{m}_n{n}_k{k}({cudatype} d[{nc}], const {cudatype} a[{na}], const {cudatype} b[{nb}], const {cudatype} c[{nc}])')
    print(f'{{')
    print(f'    asm("mma.sync.aligned.m{m}n{n}k{k}.row.col{sf}.{dtype}.{stype}.{stype}.{dtype} "')
    print(f'        "{brace_str(nc,0)}, "')
    print(f'        "{brace_str(na,nc)}, "')
    print(f'        "{brace_str(nb,nc+na)}, "')
    print(f'        "{brace_str(nc,nc+na+nb)};" :')
    print(f'        {arr_str("d",nc,ptxtype)} :')
    print(f'        {arr_str("a",na,ptxtype,const=True)},')
    print(f'        {arr_str("b",nb,ptxtype,const=True)},')
    print(f'        {arr_str("c",nc,ptxtype,const=True)}')
    print(f'    );')
    print(f'}}')
    print(f'')

    
if __name__ == '__main__':
    print(f'#ifndef _GPUTILS_DEVICE_MMA_HPP')
    print(f'#define _GPUTILS_DEVICE_MMA_HPP')
    print(f'')
    print(f'// Autogenerated by generate_device_mma_hpp.py')
    print(f'//')
    print(f'// Reference for matrix shapes:')
    print(f'//   https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#warp-level-matrix-shape')
    print(f'//')
    print(f'// Reference for PTX instruction syntax:')
    print(f'//   https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#warp-level-matrix-instructions-mma')
    print()
    print('#include <cuda_fp16.h>')
    print(f'')
    print(f'namespace gputils {{')
    print(f'')

    generate_mma('f16', 16, 8, 8)
    generate_mma('f16', 16, 8, 16)
    
    generate_mma('s4', 8, 8, 32)
    generate_mma('s4', 16, 8, 32)
    generate_mma('s4', 16, 8, 64)

    generate_mma('s8', 8, 8, 16)
    generate_mma('s8', 16, 8, 16)
    generate_mma('s8', 16, 8, 32)
    
    print(f'')
    print(f'}} // namespace gputils')
    print(f'')
    print(f'#endif // _GPUTILS_DEVICE_MMA_HPP')

